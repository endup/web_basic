首先，我们需要分析图片，获取相应的灰度信息。比如说，我们如果想要生成每行100个字符的字符画，我们就需要知道每一个字符所对应图片中的哪一块区域，我们将该区域的平均灰度获取到，然后输出一个字符,
我们用不同的字符来表示灰度，比如@表示最黑，空白表示白色，依次为：
[javascript] view plain copy
['@', 'w', '#', '$', 'k', 'd', 't', 'j', 'i', '.', ' '];  
所以，具体步骤为：
1.拿到基本信息（图片的宽高，图片的像素数据，每行要生成的字符数），通过将img画到canvas，再从canvas中获取context.drawImage(img, 0, 0, canvas.width, canvas.height);
2.计算出每个字符对应图片中的像素宽度（比如图片宽1000px,每行字符数是100个。那么每个字符对应图片中10px,这里不用考虑文字宽度，文字宽度不会影响逻辑）。由于字符的列数是一开始由每行字符数确定的，所以只要计算行数，之前计算过每个字符对应图片的像素宽度，那么高度的对应关系也是如此，将图片的高度除以该倍数就是文字的行数。
3.根据文字的行列数，开始遍历。根据图片的像素数据，在其中找出合适的灰度，然后输出对应的字符。比如，我要输出第2行第2列的文字，我就去图片中找（x:1*10,y:1*10）到（x:2*10,y:2*10）的一个矩形区域，遍历每个点的RGB值。通过gray =R * 0.3 + G * 0.59 + B * 0.11来确定某一像素点的灰度，再求这一区域的平均灰度，根据这个灰度来确定字符。
4.在字符的一行结束时输出“\r\n”以换行，获取到整个字符串后，将其放入<pre>标签忠呈现。
注意点：
所谓的imageData，其实是通过canvas的context.getImageData(x,y,width,height)方法获取到的一个对象，其中imageData.data属性可以拿到所有rgba值，比如imageData.data[0]代表第一个像素点的R值，所以每四个数表示一个像素。所以我们要获取x,y点的RGBA值，通过index = (y * imageData.width + x) * 4 可以计算得到R值data[index]，index依次+1，+2就为G,B的值,A值此处无实际作用。
还有一点要注意的是，生成的字符串要塞到<pre>标签中，不可以是div,一些特殊符号在pre中才能正常显示。



2.视频转图片
前面我们提到的图片转字符串，需要先将图片画到canvas上，再通过context的api来获取图片数据。我们知道canvas是可以画各种元素的，比如这里的视频，或者svg等等。所以，我们只需要建立video标签，然后加载视频，将视频draw到canvas上（此时为视频当前的一帧），然后通过之前的getImageData方法就可以拿到图片信息了，调用之前绘制图片的方法来绘制视频当前帧。
所以，只需要设立个timeInterval,让这个方法一秒走10次，这样字符画就会一秒更新10次，以带到同步视频播放的效果。
下面是视频的demo,由于在服务器上加载视频费用吃不消，所以视频给大家个链接，自己加载到demo上面吧。
demo：http://followyourheart.sinaapp.com/Demos/char_video.html
视频：链接: http://pan.baidu.com/s/1qWW5mhA 密码: ixsj 
可以下载视频，然后打开demo，点击选择该视频文件，然后点击播放。